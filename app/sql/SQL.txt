---------------------------------------------------------------------------- store objects
SELECT B.[name] AS [SCHEMA], A.[name] AS [OBJECT_NAME], A.[object_id] AS [OBJECT_ID]
INTO #OBJECTS
FROM [sys].[objects] AS A
INNER JOIN [sys].[schemas] AS B ON A.[schema_id] = B.[schema_id]
WHERE [type] IN ('U', 'V', 'F', 'PK', 'UQ');
---------------------------------------------------------------------------- create indexes
CREATE NONCLUSTERED INDEX ix_#OBJECTS ON #OBJECTS ([SCHEMA], [OBJECT_NAME]);
CREATE NONCLUSTERED INDEX ix2_#OBJECTS ON #OBJECTS ([OBJECT_ID]) INCLUDE ([SCHEMA], [OBJECT_NAME]);
---------------------------------------------------------------------------- store constraints
SELECT T.[TABLE_SCHEMA]
  , T.[TABLE_NAME]
  , A.[OBJECT_ID] AS [CONSTRAINT_ID]
  , T.[CONSTRAINT_NAME]
  , CASE T.[CONSTRAINT_TYPE] 
	  WHEN N'PRIMARY KEY' THEN 1
	  WHEN N'UNIQUE' THEN 2
	  ELSE 3
    END AS [CONSTRAINT_TYPE]
  , 0 AS IS_RK
  , 0 AS FK_ORDER
INTO #CONSTRAINTS
FROM (
SELECT [TABLE_SCHEMA]
  ,[TABLE_NAME]
  ,[CONSTRAINT_NAME]
  ,[CONSTRAINT_TYPE] 
FROM [INFORMATION_SCHEMA].[TABLE_CONSTRAINTS]
WHERE [CONSTRAINT_TYPE] <> N'CHECK'  
  AND [TABLE_NAME] IS NOT NULL
) AS T
INNER JOIN #OBJECTS AS A 
	ON T.[TABLE_SCHEMA] = A.[SCHEMA]
	AND T.[CONSTRAINT_NAME] = A.[OBJECT_NAME];
---------------------------------------------------------------------------- create indexes
CREATE NONCLUSTERED INDEX ix_#CONSTRAINTS ON #CONSTRAINTS (TABLE_SCHEMA, TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_ID);
CREATE NONCLUSTERED INDEX ix2_#CONSTRAINTS ON #CONSTRAINTS (CONSTRAINT_TYPE) INCLUDE (TABLE_SCHEMA, TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_ID);
---------------------------------------------------------------------------- remove sql_variant/nullable PK/UK
DELETE X
FROM #CONSTRAINTS AS X
WHERE EXISTS (
	SELECT NULL
	FROM [INFORMATION_SCHEMA].[KEY_COLUMN_USAGE] AS AA
	INNER JOIN [INFORMATION_SCHEMA].[COLUMNS] AS BB
		ON AA.[TABLE_SCHEMA] = BB.[TABLE_SCHEMA]
		AND AA.[TABLE_NAME] = BB.[TABLE_NAME]
		AND AA.[COLUMN_NAME] = BB.[COLUMN_NAME]
	WHERE X.[TABLE_SCHEMA] = AA.[CONSTRAINT_SCHEMA]
		AND X.[CONSTRAINT_NAME] = AA.[CONSTRAINT_NAME]	
		AND (BB.[DATA_TYPE] = 'sql_variant'	OR BB.[IS_NULLABLE] = 'YES')
)
AND X.CONSTRAINT_TYPE IN (1, 2);
---------------------------------------------------------------------------- set IS_RK
UPDATE X
SET X.IS_RK = 1
FROM #CONSTRAINTS AS X
INNER JOIN (
	SELECT BB.[TABLE_SCHEMA], BB.[TABLE_NAME], BB.[CONSTRAINT_ID], BB.[CONSTRAINT_NAME]
	FROM (
		SELECT [TABLE_SCHEMA], [TABLE_NAME], MIN([CONSTRAINT_TYPE]) AS MIN_CONSTRAINT_TYPE
		FROM #CONSTRAINTS
		WHERE [CONSTRAINT_TYPE] < 3
		GROUP BY [TABLE_SCHEMA], [TABLE_NAME]
	) AS AA
	CROSS APPLY (
		SELECT TOP(1) AAA.[TABLE_SCHEMA], AAA.[TABLE_NAME], AAA.[CONSTRAINT_ID], AAA.[CONSTRAINT_NAME]
		FROM #CONSTRAINTS AS AAA
		WHERE AAA.[TABLE_SCHEMA] = AA.[TABLE_SCHEMA] 
		AND AAA.[TABLE_NAME] = AA.[TABLE_NAME]
		AND AAA.[CONSTRAINT_TYPE] = AA.[MIN_CONSTRAINT_TYPE]
	) AS BB
) AS A ON A.[CONSTRAINT_ID] = X.[CONSTRAINT_ID];
---------------------------------------------------------------------------- set FK order (for crossing FK)
UPDATE X
SET X.[FK_ORDER] = A.[FK_ORDER]
FROM #CONSTRAINTS AS X
INNER JOIN (
	SELECT T.[TABLE_SCHEMA], T.[TABLE_NAME], T.[CONSTRAINT_NAME], T.[CONSTRAINT_ID]
		, ROW_NUMBER() OVER (
			PARTITION BY T.[TABLE_SCHEMA], T.[TABLE_NAME]
			ORDER BY T.[COLUMN_COUNT]) AS FK_ORDER
	FROM (
		SELECT AA.[TABLE_SCHEMA], AA.[TABLE_NAME], AA.[CONSTRAINT_NAME], AA.[CONSTRAINT_ID], COUNT(*) AS COLUMN_COUNT
		FROM #CONSTRAINTS AS AA
		INNER JOIN [INFORMATION_SCHEMA].[KEY_COLUMN_USAGE] AS BB
			ON AA.[TABLE_SCHEMA] = BB.[CONSTRAINT_SCHEMA]
			AND AA.[CONSTRAINT_NAME] = BB.[CONSTRAINT_NAME]	
		WHERE AA.[CONSTRAINT_TYPE] = 3
		GROUP BY AA.[TABLE_SCHEMA], AA.[TABLE_NAME], AA.[CONSTRAINT_NAME], AA.[CONSTRAINT_ID]
	) AS T
) AS A ON X.[CONSTRAINT_ID] = A.[CONSTRAINT_ID];
---------------------------------------------------------------------------- remove crossing FK (without priority)
SELECT E.[TABLE_SCHEMA], E.[TABLE_NAME], E.[CONSTRAINT_ID], E.[CONSTRAINT_NAME], T.[COLUMN_NAME]
INTO #CONSTRAINT2 -- for optimization
FROM (
SELECT AA.[TABLE_SCHEMA], AA.[TABLE_NAME], BB.[COLUMN_NAME]
	, MIN(AA.[FK_ORDER]) AS [FK_ORDER]
FROM #CONSTRAINTS AS AA
INNER JOIN [INFORMATION_SCHEMA].[KEY_COLUMN_USAGE] AS BB
	ON AA.[TABLE_SCHEMA] = BB.[CONSTRAINT_SCHEMA]
	AND AA.[CONSTRAINT_NAME] = BB.[CONSTRAINT_NAME]	
WHERE AA.[CONSTRAINT_TYPE] = 3
GROUP BY AA.[TABLE_SCHEMA], AA.[TABLE_NAME], BB.[COLUMN_NAME]
) AS T 
INNER JOIN #CONSTRAINTS AS E
	ON T.[TABLE_SCHEMA] = E.[TABLE_SCHEMA]
	AND T.[TABLE_NAME] = E.[TABLE_NAME]
	AND T.[FK_ORDER] = E.[FK_ORDER];
DELETE X
FROM #CONSTRAINTS AS X
WHERE EXISTS (
	SELECT NULL
	FROM [INFORMATION_SCHEMA].[KEY_COLUMN_USAGE] AS C
	LEFT OUTER JOIN #CONSTRAINT2 AS A
		ON A.[TABLE_SCHEMA] = C.[CONSTRAINT_SCHEMA]
		AND A.[CONSTRAINT_NAME] = C.[CONSTRAINT_NAME]	
		AND A.[COLUMN_NAME] = C.[COLUMN_NAME]
	WHERE X.[TABLE_SCHEMA] = C.[TABLE_SCHEMA]
	AND X.[CONSTRAINT_NAME] = C.[CONSTRAINT_NAME]
	AND A.[CONSTRAINT_ID] IS NULL
)
AND X.[CONSTRAINT_TYPE] = 3;
---------------------------------------------------------------------------- store relations
SELECT
	B1.[TABLE_SCHEMA] AS [NODE_SCHEMA]				-- needed! 
	, T1.[OBJECT_ID] AS [NODE_ID]
	, B1.[CONSTRAINT_ID] AS [NODE_CONSTRAINT_ID]	-- FK
	, B2.[TABLE_SCHEMA] AS [RELATED_SCHEMA]			-- nedded!
	, T2.[OBJECT_ID] AS [RELATED_ID]
	, B2.[CONSTRAINT_ID] AS [RELATED_CONSTRAINT_ID] -- RK
	, CASE WHEN T1.[OBJECT_ID] = T2.[OBJECT_ID] THEN 10
	  ELSE 0 END AS [RELATION_TYPE]					-- ManyToOne or Self
	, 0 AS [COLUMN_COUNT]							-- needed for SingleToOne relations
INTO #RELATIONS
FROM [INFORMATION_SCHEMA].[REFERENTIAL_CONSTRAINTS] AS A
INNER JOIN #CONSTRAINTS AS B1	
	ON A.[CONSTRAINT_SCHEMA] = B1.[TABLE_SCHEMA]
	AND A.[CONSTRAINT_NAME] = B1.[CONSTRAINT_NAME]
INNER JOIN #OBJECTS AS T1
	ON B1.[TABLE_SCHEMA] = T1.[SCHEMA]
	AND B1.[TABLE_NAME] = T1.[OBJECT_NAME]
INNER JOIN #CONSTRAINTS AS B2
	ON A.[UNIQUE_CONSTRAINT_SCHEMA] = B2.[TABLE_SCHEMA]
	AND A.[UNIQUE_CONSTRAINT_NAME] = B2.[CONSTRAINT_NAME]
INNER JOIN #OBJECTS AS T2
	ON B2.[TABLE_SCHEMA] = T2.[SCHEMA]
	AND B2.[TABLE_NAME] = T2.[OBJECT_NAME];
---------------------------------------------------------------------------- create indexes
CREATE NONCLUSTERED INDEX ix_RELATIONS ON #RELATIONS ([NODE_CONSTRAINT_ID],[NODE_SCHEMA],[COLUMN_COUNT]);
CREATE NONCLUSTERED INDEX ix2_RELATIONS ON #RELATIONS ([NODE_ID],[RELATED_ID]);
---------------------------------------------------------------------------- remove UK without relations
DELETE X
FROM #CONSTRAINTS AS X
WHERE NOT EXISTS (
	SELECT NULL
	FROM #RELATIONS AS AA
	WHERE AA.[RELATED_SCHEMA] = X.[TABLE_SCHEMA]
		AND AA.[RELATED_CONSTRAINT_ID] = X.[CONSTRAINT_ID]
)
AND X.CONSTRAINT_TYPE = 2
AND X.IS_RK = 0;
---------------------------------------------------------------------------- store column usage
SELECT D.[OBJECT_ID] AS [CONSTRAINT_ID] 
	, A.[TABLE_NAME]
	, B.[OBJECT_ID] AS [NODE_ID]
	, A.[COLUMN_NAME]
	, A.[ORDINAL_POSITION]
	, ROW_NUMBER() OVER (
		PARTITION BY A.[CONSTRAINT_NAME], B.[OBJECT_ID]
		ORDER BY A.[ORDINAL_POSITION]
		) AS [COLUMN_POSITION]	-- re-ordening (to be able to join columns by its ordinal position)
INTO #COLUMN_USAGE
FROM [INFORMATION_SCHEMA].[KEY_COLUMN_USAGE] AS A
INNER JOIN #OBJECTS AS B
	ON A.[TABLE_SCHEMA] = B.[SCHEMA]
	AND A.[TABLE_NAME] = B.[OBJECT_NAME]
INNER JOIN #CONSTRAINTS AS C 
	ON B.[SCHEMA] = C.[TABLE_SCHEMA]
	AND A.[CONSTRAINT_NAME] = C.[CONSTRAINT_NAME]
INNER JOIN #OBJECTS AS D
	ON A.[TABLE_SCHEMA] = D.[SCHEMA]
	AND A.[CONSTRAINT_NAME] = D.[OBJECT_NAME];
---------------------------------------------------------------------------- store relation columns
SELECT A.NODE_CONSTRAINT_ID 
	, A.[NODE_SCHEMA]
	, C1.[TABLE_NAME] AS [NODE_NAME]
	, A.[NODE_ID]
	, C1.[COLUMN_NAME] AS [NODE_COLUMN_NAME]
	, A.[RELATED_SCHEMA]
	, C2.[TABLE_NAME] AS [RELATED_NAME]
	, A.[RELATED_ID]
	, C2.[COLUMN_NAME] AS [RELATED_COLUMN_NAME]
INTO #RELATION_COLUMNS
FROM #RELATIONS AS A
INNER JOIN #COLUMN_USAGE AS C1 ON A.NODE_CONSTRAINT_ID = C1.CONSTRAINT_ID
INNER JOIN #COLUMN_USAGE AS C2 ON A.RELATED_CONSTRAINT_ID = C2.CONSTRAINT_ID
WHERE C1.[COLUMN_POSITION] = C2.[COLUMN_POSITION];
---------------------------------------------------------------------------- create indexes
CREATE NONCLUSTERED INDEX ix_RELATION_COLUMNS ON #RELATION_COLUMNS ([NODE_CONSTRAINT_ID]);
CREATE NONCLUSTERED INDEX ix2_RELATION_COLUMNS ON #RELATION_COLUMNS ([NODE_SCHEMA],[NODE_NAME],[NODE_COLUMN_NAME]);
CREATE NONCLUSTERED INDEX ix3_RELATION_COLUMNS ON #RELATION_COLUMNS ([RELATED_SCHEMA],[RELATED_NAME],[RELATED_COLUMN_NAME]);
SELECT C.[OBJECT_ID] AS [CONSTRAINT_ID], A.[TABLE_SCHEMA], A.[TABLE_NAME], B.[CONSTRAINT_NAME], A.[COLUMN_NAME], 0 AS [COLUMN_COUNT]
INTO #UKS
FROM [INFORMATION_SCHEMA].[CONSTRAINT_COLUMN_USAGE] AS A
INNER JOIN [INFORMATION_SCHEMA].[TABLE_CONSTRAINTS] AS B
	ON A.[TABLE_SCHEMA] = B.[TABLE_SCHEMA]
	AND A.[CONSTRAINT_NAME] = B.[CONSTRAINT_NAME]
INNER JOIN #OBJECTS AS C ON B.[TABLE_SCHEMA] = C.[SCHEMA] AND B.[CONSTRAINT_NAME] = C.[OBJECT_NAME]
WHERE B.[CONSTRAINT_TYPE] IN ('PRIMARY KEY', 'UNIQUE');
---------------------------------------------------------------------------- prepare column count
UPDATE X 
SET X.[COLUMN_COUNT] = A.[COLUMN_COUNT]
FROM #RELATIONS AS X
INNER JOIN (
	SELECT AA.[NODE_CONSTRAINT_ID], COUNT(*) AS [COLUMN_COUNT]
	FROM #RELATIONS AS AA
	INNER JOIN #RELATION_COLUMNS AS BB ON AA.[NODE_CONSTRAINT_ID] = BB.[NODE_CONSTRAINT_ID]
	GROUP BY AA.[NODE_CONSTRAINT_ID] 
) AS A ON X.[NODE_CONSTRAINT_ID] = A.[NODE_CONSTRAINT_ID];
---------------------------------------------------------------------------- store column count into UKs
UPDATE X 
SET X.[COLUMN_COUNT] = A.[COLUMN_COUNT]
FROM #UKS AS X
INNER JOIN (
	SELECT [CONSTRAINT_ID], COUNT(*) AS [COLUMN_COUNT]
	FROM #UKS
	GROUP BY [CONSTRAINT_ID] 
) AS A ON X.[CONSTRAINT_ID] = A.[CONSTRAINT_ID];
---------------------------------------------------------------------------- set single-to-one relations
WITH _MATCH AS
(
SELECT A.[NODE_CONSTRAINT_ID] AS [FK_ID]
	, B.[OBJECT_NAME] AS [FK_NAME]
	, D.[CONSTRAINT_NAME] AS [UK_NAME]
	, A.[COLUMN_COUNT]
FROM #RELATIONS AS A
INNER JOIN #OBJECTS AS B ON A.[NODE_CONSTRAINT_ID] = B.[OBJECT_ID]
INNER JOIN [INFORMATION_SCHEMA].[CONSTRAINT_COLUMN_USAGE] AS C
	ON A.[NODE_SCHEMA] = C.[TABLE_SCHEMA]
	AND B.[OBJECT_NAME] = C.[CONSTRAINT_NAME]
INNER JOIN #UKS AS D
	ON A.[NODE_SCHEMA] = D.[TABLE_SCHEMA]
	AND C.[TABLE_NAME] = D.[TABLE_NAME]
	AND C.[COLUMN_NAME] = D.[COLUMN_NAME]
	AND A.[COLUMN_COUNT] = D.[COLUMN_COUNT]
)
UPDATE X
SET X.[RELATION_TYPE] = 2
FROM #RELATIONS AS X
WHERE EXISTS (
	SELECT NULL 
	FROM _MATCH AS A
	WHERE A.[FK_ID] = X.[NODE_CONSTRAINT_ID]
	GROUP BY A.[FK_ID], A.[UK_NAME]
	HAVING COUNT(*) = MIN(A.COLUMN_COUNT)
);
----------------------------------------------------------------------------
-- OUTPUT
---------------------------------------------------------------------------- output: tables/views
SELECT B.[OBJECT_ID]
  , A.[TABLE_SCHEMA] AS [SCHEMA]
  , A.[TABLE_NAME] AS [OBJECT_NAME]
  , CASE 
	  WHEN A.[TABLE_TYPE] = N'BASE TABLE' THEN 1
      ELSE 2 END 
	AS [OBJECT_TYPE] 
FROM [INFORMATION_SCHEMA].[TABLES] AS A
INNER JOIN #OBJECTS AS B 
	ON A.[TABLE_SCHEMA] = B.[SCHEMA]
	AND A.[TABLE_NAME] = B.[OBJECT_NAME];
---------------------------------------------------------------------------- output: funcs/procs
SELECT [ROUTINE_SCHEMA] AS [SCHEMA]
  , [ROUTINE_NAME] AS [OBJECT_NAME]
  , CASE 
	  WHEN [DATA_TYPE] IS NULL THEN 5 
	  ELSE CASE WHEN [DATA_TYPE] = N'TABLE' THEN 3 ELSE 4 END 
	END AS [OBJECT_TYPE]
  , LOWER([DATA_TYPE]) AS [RETURN_DTYPE]
  , CAST(ISNULL([CHARACTER_MAXIMUM_LENGTH],[DATETIME_PRECISION]) AS [int]) AS [RETURN_LENGTH]
  , CAST([NUMERIC_PRECISION] AS [int]) AS [RETURN_PRECISION]
  , CAST([NUMERIC_SCALE] AS [int]) AS [RETURN_SCALE] 
FROM [INFORMATION_SCHEMA].[ROUTINES];
---------------------------------------------------------------------------- output: columns
SELECT DISTINCT A.[SCHEMA]	-- distinct needed due to the last outer join
  , A.[OBJECT_NAME]
  , A.[COLUMN_NAME]
  , A.[ORDINAL_POSITION]
  , CASE 
	  WHEN D.[is_identity] = 1 THEN 1 
	  WHEN (LOWER(A.[DTYPE]) = N'rowversion' OR LOWER(A.[DTYPE]) = N'timestamp') THEN 2
	  WHEN D.[is_computed] = 1 THEN 3 
      ELSE 0 
	END AS [COLUMN_TYPE]
  , A.[IS_NULLABLE]
  , CAST(ISNULL(A.[IS_RK], 0) AS bit) AS [IS_RK]
  , CAST(ISNULL(CASE WHEN F.[NODE_SCHEMA] IS NULL THEN 0 ELSE A.[IS_UK] END, 0) AS bit) AS [IS_UK]
  , CAST(ISNULL(CASE WHEN E.[NODE_SCHEMA] IS NULL THEN 0 ELSE A.[IS_FK] END, 0) AS bit) AS [IS_FK]
  , A.[DTYPE]
  , A.[LENGTH]
  , A.[PRECISION]
  , A.[SCALE]
  , CAST(A.[HAS_DEFAULT] AS bit) AS [HAS_DEFAULT]
 FROM (
	-- tables, views
	SELECT A.[TABLE_SCHEMA] AS [SCHEMA]
	  , A.[TABLE_NAME] AS [OBJECT_NAME]
	  , A.[COLUMN_NAME] AS [COLUMN_NAME]
	  , A.[ORDINAL_POSITION]
	  , CAST(CASE WHEN A.[IS_NULLABLE] = N'YES' THEN 1 ELSE 0 END AS bit) AS [IS_NULLABLE]
	  , CAST(B.[IS_RK] AS bit) AS [IS_RK]
	  , CAST(B.[IS_UK] AS bit) AS [IS_UK]
	  , CAST(B.[IS_FK] AS bit) AS [IS_FK]
	  , A.[DATA_TYPE] AS [DTYPE]
	  , CAST(ISNULL(A.[CHARACTER_MAXIMUM_LENGTH], A.[DATETIME_PRECISION]) AS [int]) AS [LENGTH]
	  , CAST(A.[NUMERIC_PRECISION] AS [int]) AS [PRECISION]
	  , CAST(A.[NUMERIC_SCALE] AS [int]) AS [SCALE] 
	  , CASE WHEN A.[COLUMN_DEFAULT] IS NULL THEN 0 ELSE 1 END AS HAS_DEFAULT
	FROM [INFORMATION_SCHEMA].[COLUMNS] AS A 
	LEFT OUTER JOIN (
		SELECT AA.[TABLE_SCHEMA]
		  , AA.[TABLE_NAME]
		  , BB.[COLUMN_NAME]
		  , MAX(AA.[IS_RK]) AS [IS_RK]
		  , MAX(CASE WHEN AA.[CONSTRAINT_TYPE] = 2 THEN 1 ELSE 0 END) AS [IS_UK]
		  , MAX(CASE WHEN AA.[CONSTRAINT_TYPE] = 3 THEN 1 ELSE 0 END) AS [IS_FK]
		FROM #CONSTRAINTS AS AA 
		INNER JOIN [INFORMATION_SCHEMA].[CONSTRAINT_COLUMN_USAGE] AS BB 
		  ON AA.[TABLE_SCHEMA] = BB.[TABLE_SCHEMA]   
		  AND AA.[CONSTRAINT_NAME] = BB.[CONSTRAINT_NAME]  
		GROUP BY AA.[TABLE_SCHEMA], AA.[TABLE_NAME], BB.[COLUMN_NAME]
	) AS B 
	ON A.[TABLE_SCHEMA] = B.[TABLE_SCHEMA]  
	AND A.[TABLE_NAME] = B.[TABLE_NAME]  
	AND A.[COLUMN_NAME] = B.[COLUMN_NAME]  
	UNION ALL
	-- routines
	SELECT A2.[TABLE_SCHEMA] AS [SCHEMA]
	  , A2.[TABLE_NAME] AS [OBJECT_NAME]
	  , A2.[COLUMN_NAME] AS [COLUMN_NAME]
	  , A2.[ORDINAL_POSITION]
	  , CAST(CASE WHEN A2.[IS_NULLABLE] = N'YES' THEN 1 ELSE 0 END AS bit) AS [IS_NULLABLE]
	  , 0 AS [IS_RK]
	  , 0 AS [IS_UK]
	  , 0 AS [IS_FK]
	  , A2.[DATA_TYPE] AS [DTYPE]
	  , CAST(ISNULL(A2.[CHARACTER_MAXIMUM_LENGTH], A2.[DATETIME_PRECISION]) AS [int]) AS [LENGTH]
	  , CAST(A2.[NUMERIC_PRECISION] AS [int]) AS [PRECISION]
	  , CAST(A2.[NUMERIC_SCALE] AS [int]) AS [SCALE] 
	  , 0 AS [HAS_DEFAULT]
	FROM [INFORMATION_SCHEMA].[ROUTINE_COLUMNS] AS A2
) AS A 
INNER JOIN [sys].[schemas] AS B 
  ON A.[SCHEMA] = B.[name]  
INNER JOIN [sys].[objects] AS C
  ON B.[schema_id] = C.[schema_id]  
  AND A.[OBJECT_NAME] = C.[name]  
INNER JOIN [sys].[columns] AS [D] 
  ON C.[object_id] = D.[object_id]  
  AND A.[COLUMN_NAME] = D.[name]
LEFT OUTER JOIN #RELATION_COLUMNS AS [E]		-- FK
	ON A.[SCHEMA] = E.[NODE_SCHEMA]
	AND A.[OBJECT_NAME] = E.[NODE_NAME]
	AND A.[COLUMN_NAME] = E.[NODE_COLUMN_NAME]
LEFT OUTER JOIN #RELATION_COLUMNS AS [F]		-- UK (this join makes duplicates)
	ON A.[SCHEMA] = F.[RELATED_SCHEMA]
	AND A.[OBJECT_NAME] = F.[RELATED_NAME]
	AND A.[COLUMN_NAME] = F.[RELATED_COLUMN_NAME];
---------------------------------------------------------------------------- output: params
SELECT A.[ROUTINE_SCHEMA] AS [SCHEMA]
  , A.[ROUTINE_NAME] AS [OBJECT_NAME]
  , CASE WHEN RTRIM(B.[PARAMETER_NAME]) = N'' THEN NULL ELSE B.[PARAMETER_NAME] END AS [PARAMETER_NAME]
  , CASE B.[PARAMETER_MODE] 
	  WHEN N'IN' THEN 1 
	  WHEN N'INOUT' THEN 2
	  WHEN N'OUT' THEN 3 
      ELSE 0 
	END AS [PARAMETER_MODE]
  , ISNULL(B.[ORDINAL_POSITION], 0) AS [ORDINAL_POSITION]
  , B.[DATA_TYPE] AS [DTYPE]
  , CAST(ISNULL(B.[CHARACTER_MAXIMUM_LENGTH], B.[DATETIME_PRECISION]) AS [int]) AS [LENGTH]
  , CAST(B.[NUMERIC_PRECISION] AS [int]) AS [PRECISION]
  , CAST(B.[NUMERIC_SCALE] AS [int]) AS [SCALE]
  , B.[USER_DEFINED_TYPE_SCHEMA] AS [UDT_SCHEMA]
  , B.[USER_DEFINED_TYPE_NAME] AS [UDT_NAME] 
FROM [INFORMATION_SCHEMA].[ROUTINES] AS A 
LEFT OUTER JOIN [INFORMATION_SCHEMA].[PARAMETERS] AS B 
  ON A.[ROUTINE_SCHEMA] = B.[SPECIFIC_SCHEMA]  
  AND A.[ROUTINE_NAME] = B.[SPECIFIC_NAME]; 
---------------------------------------------------------------------------- output: relations
WITH _MANY AS
(
	SELECT [NODE_ID], [RELATED_ID]
	FROM #RELATIONS
	GROUP BY [NODE_ID], [RELATED_ID]
	HAVING COUNT(*) > 1
)
SELECT A.[NODE_CONSTRAINT_ID] AS [RELATION_ID], A.[RELATION_TYPE], A.[NODE_ID], A.[RELATED_ID]
	, CAST(CASE WHEN B.[NODE_ID] IS NULL THEN 0 ELSE 1 END AS bit) AS HAS_MANY
FROM #RELATIONS AS A
LEFT OUTER JOIN _MANY AS B
	ON A.NODE_ID = B.NODE_ID
	AND A.RELATED_ID = B.RELATED_ID;
---------------------------------------------------------------------------- output: relation columns
SELECT A.[NODE_CONSTRAINT_ID] AS [RELATION_ID], A.[NODE_ID], B.[COLUMN_NAME], B.[ORDINAL_POSITION] AS [COLUMN_ORDINAL]
	, A.[RELATED_ID], C.[COLUMN_NAME] AS [RELATED_COLUMN_NAME], C.[ORDINAL_POSITION] AS [RELATED_COLUMN_ORDINAL]
	, R.[RELATION_TYPE]
FROM #RELATION_COLUMNS AS A
INNER JOIN [INFORMATION_SCHEMA].[COLUMNS] AS B 
	ON A.[NODE_SCHEMA] = B.[TABLE_SCHEMA]
	AND A.[NODE_NAME] = B.[TABLE_NAME]
	AND A.[NODE_COLUMN_NAME] = B.[COLUMN_NAME]
INNER JOIN [INFORMATION_SCHEMA].[COLUMNS] AS C 
	ON A.[RELATED_SCHEMA] = C.[TABLE_SCHEMA]
	AND A.[RELATED_NAME] = C.[TABLE_NAME]
	AND A.[RELATED_COLUMN_NAME] = C.[COLUMN_NAME]
INNER JOIN #RELATIONS AS R 
	ON A.NODE_CONSTRAINT_ID = R.NODE_CONSTRAINT_ID;
